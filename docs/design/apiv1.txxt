                            dodot API v1 Design


1. Overview 

    This document defines the API for dodot's v1 implementation, incorporating the improved 
    design with separate Triggers, Power-ups, and Matchers. The API follows functional 
    programming principles and leverages the fsynth library for safe filesystem operations.

    The core insight is that we need three distinct entities:
        - Triggers: Pure matching logic (what files to match)
        - Power-ups: Pure processing logic (what to do with matched files)
        - Matchers: Configuration connecting triggers to power-ups

2. Core Data Types

    2.1 Trigger Interface
        
        A trigger is a pure function that determines if a file should be processed.
        All triggers implement this interface:

            local trigger = {
                type = "string",        -- trigger type identifier
                match = function(self, file_path, pack_path)
                    -- Returns: boolean, metadata_table
                end,
                validate = function(self)
                    -- Returns: boolean, error_message
                end
            }

    2.2 Power-up Interface
        
        A power-up processes matched files and returns a list of actions.

            local power_up = {
                name = "string",        -- power-up identifier
                process = function(matched_files, pack_path, options)
                    -- matched_files: array of {path, metadata} 
                    -- Returns: array_of_actions, error_message_or_nil
                end,
                validate = function(matched_files, pack_path, options)
                    -- Returns: boolean, error_message
                end
            }

    2.3 Matcher Configuration
        
        Matchers connect triggers to power-ups with priority and options.

            local matcher = {
                trigger = trigger_instance,
                power_up = "power_up_name",
                priority = number,      -- higher wins conflicts
                options = {}            -- passed to power-up.process
            }

    2.4 Action Types
        
        Actions represent high-level operations to be performed.

            local action = {
                type = "string",        -- action type
                description = "string", -- human readable
                data = {},             -- action-specific data
                pack_source = "string", -- source pack
                priority = number       -- execution order
            }

3. Standard Trigger Types

    3.1 FileNameTrigger
        
        Matches files based on glob patterns.

            local file_trigger = FileNameTrigger.new(patterns, options)

        Options:
            case_sensitive = boolean (default: true)
            recursive = boolean (default: false)
            exclude_patterns = array of strings

    3.2 DirectoryTrigger
        
        Matches directories by name and properties.

            local dir_trigger = DirectoryTrigger.new(name, options)

        Options:
            must_exist = boolean (default: true)
            must_be_executable = boolean (default: false)

    3.3 ExtensionTrigger
        
        Matches files by extension.

            local ext_trigger = ExtensionTrigger.new(extensions)

        Extensions: array of strings like {".sh", ".zsh", ".bash"}

    3.4 ContentTrigger
        
        Matches files by content patterns.

            local content_trigger = ContentTrigger.new(pattern, options)

        Options:
            location = "first_line" | "anywhere" | "last_line"
            max_file_size = number (default: 1MB)

4. Standard Power-ups

    4.1 link
        
        Creates symlinks to files and directories.

            Actions produced: link
            Options: 
                base = "home" | "xdg_config" (default: "home")
                overwrite = boolean (default: false)
                backup = boolean (default: false)

    4.2 shell_profile
        
        Adds shell scripts to the user's profile.

            Actions produced: shell_source
            Options: shell_types, order

    4.3 shell_add_path
        
        Adds directories to the shell's PATH.

            Actions produced: shell_add_path
            Options: prepend, shell_types

    4.4 homebrew
        
        Installs packages via Homebrew.

            Actions produced: brew_install
            Options: update_existing, install_casks

    4.5 script_runner
        
        Executes setup scripts.

            Actions produced: script_run
            Options: run_once, working_directory

5. Configuration API

    5.1 Default Matchers
        
        The system provides sensible defaults:

            local default_matchers = {
                -- Package managers (highest priority)
                {
                    trigger = FileNameTrigger.new({"Brewfile", "Brewfile.*"}),
                    power_up = "homebrew",
                    priority = 80
                },
                
                -- Shell configuration
                {
                    trigger = FileNameTrigger.new({"alias.*", "aliases.*"}),
                    power_up = "shell_profile",
                    priority = 70
                },
                
                -- Executable directories
                {
                    trigger = DirectoryTrigger.new("bin"),
                    power_up = "shell_add_path", 
                    priority = 60
                },
                
                -- Default symlink (lowest priority)
                {
                    trigger = FileNameTrigger.new({".*"}),
                    power_up = "link",
                    priority = 10
                }
            }

    5.2 User Customization
        
        Users can override matchers in .dodot.toml:

            [matchers]
            [[matchers.add]]
            trigger = {type = "file_name", patterns = ["packages.txt"]}
            power_up = "homebrew"
            priority = 85

6. Core API Functions

    6.1 Main Pipeline
        
            local dodot = require("dodot.core")

            -- 1. Discover packs
            local packs = dodot.get_packs(dotfiles_root)
            
            -- 2. Get active matchers (default + user config)
            local matchers = dodot.get_matchers(config)
            
            -- 3. Find matches across all packs
            local matches = dodot.get_matches(packs, matchers)
            
            -- 4. Generate actions from matches
            local actions = dodot.get_actions(matches)
            
            -- 5. Convert to filesystem operations
            local operations = dodot.get_operations(actions)
            
            -- 6. Execute with fsynth
            local results = fsynth.execute(operations)

    6.2 Matcher Resolution
        
            function dodot.get_matches(packs, matchers)
                local all_matches = {}
                
                for _, pack in ipairs(packs) do
                    local pack_files = scan_pack(pack.path)
                    
                    for _, file in ipairs(pack_files) do
                        for _, matcher in ipairs(matchers) do
                            local matched, metadata = matcher.trigger:match(file, pack.path)
                            if matched then
                                table.insert(all_matches, {
                                    file = file,
                                    pack = pack,
                                    matcher = matcher,
                                    metadata = metadata
                                })
                            end
                        end
                    end
                end
                
                return resolve_conflicts(all_matches)
            end

    6.3 Action Generation
        
            function dodot.get_actions(matches)
                local actions = {}
                local grouped = group_by_powerup(matches)
                
                for power_up_name, match_group in pairs(grouped) do
                    local power_up = get_power_up(power_up_name)
                    local files = extract_files(match_group)
                    local options = merge_options(match_group)
                    
                    local power_up_actions = power_up:process(files, options)
                    for _, action in ipairs(power_up_actions) do
                        table.insert(actions, action)
                    end
                end
                
                return sort_by_priority(actions)
            end

7. Action to Operation Mapping

    7.1 Action Types to fsynth Operations
        
            link -> fsynth.op.symlink
            shell_source -> fsynth.op.create_file + fsynth.op.symlink
            shell_add_path -> fsynth.op.create_file
            brew_install -> fsynth.op.script_run
            script_run -> fsynth.op.script_run

    7.2 Operation Builder
        
            function build_operations(actions)
                local operations = {}
                
                for _, action in ipairs(actions) do
                    local builders = operation_builders[action.type]
                    if builders then
                        local ops = builders(action)
                        for _, op in ipairs(ops) do
                            table.insert(operations, op)
                        end
                    end
                end
                
                return operations
            end

8. Testing and Validation

    8.1 Dry Run Support
        
        All operations support dry-run mode via fsynth:

            local results = fsynth.execute(operations, {dry_run = true})

    8.2 Validation Pipeline
        
        Each component validates its inputs:

            -- Trigger validation
            local valid, err = trigger:validate()
            
            -- Power-up validation  
            local valid, err = power_up:validate(files, pack_path, options)
            
            -- Operation validation
            local valid, err = operation:validate()

9. Configuration Integration

    9.1 Melt Integration
        
        Configuration loading uses the melt library:

            local config = melt.load({
                {type = "file", path = "~/.dodot.toml"},
                {type = "file", path = pack_path .. "/.dodot.toml"},
                {type = "env", prefix = "DODOT_"},
                {type = "defaults", values = default_config}
            })

    9.2 Pack-specific Overrides
        
        Each pack can override matchers:

            [matchers]
            disable = ["homebrew", "script_runner"]
            
            [[matchers.add]]
            trigger = {type = "file_name", patterns = ["*.custom"]}
            power_up = "custom_handler"
            priority = 90

This API design provides a clean separation of concerns while maintaining the flexibility 
to handle diverse dotfile configurations. The matcher system allows users to customize 
behavior without modifying code, and the integration with fsynth provides robust 
filesystem operation handling.