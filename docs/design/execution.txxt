dodot Implementation and Execution
                

1. Overview 
    
    This is the implementation side of dodot, read the docs/concepts-and-design.txxt for the reasoning.

    The execution pipeline follows these steps:
        1. Get configuration, resolve DOTFILES dir.
        2. Resolve pack names to paths, and validate (read access, no ignore, etc) (validate packs)
        3. Through each pack: (get firing triggers) -> array of trigger matches and their power-ups
            a. Resolve configuration including the pack's toml (if there is one)
            b. Run triggers and accumulate which ones fire (get firing triggers)
        4. Activate power-ups (gets a list of actions) -> array of actions per power-up
            a. Iterate the active triggers running their power-ups for each pack and accumulating their actions (get power-ups actions)
        5. Plan Actions: -> array of simple synthetic file system operations to run
            a. Iterating their actions and transforming them into fsynth operations (get fs operations)
        6. Run: actually execute these changes
            a. Execute all operations (the fsynth lib does the execution) (run operations)

    And the implementation for triggers, actions, and power-ups.

2. Libraries
    
    As we planned we either found or created lua libraries that handle an abstract lower level part of the 
    problem. These are: 

        - fsynth (https://luarocks.org/modules/arthur-debert/fsynth) 0.1.0 This is the one we created for this 
        specific problem and hence it should serve us well. It has an api for creating file system operations
        and a runner to run it, as well as facilities for visualizing it.  /Users/adebert/h/lua/fsynth.lua/fsynth and 
        /Users/adebert/h/lua/fsynth.lua/docs

        - melt (https://luarocks.org/modules/arthur-debert/melt) 0.1.1 This rock allows you to declare a 
        chain of configuration (can be files, env vars, command line options) and get back a unified one, 
        merged in the right order. Locally source code and docs ~/h/lua/lua.melt/docs ~/h/lua/lua.melt/lua

3. Design Principles

    3.1. Functional Programming
        
        We favor a functional programming style for the various benefits that it allows. Given that the most 
        difficult part to make functional are all file system operations, we should have no difficulty with the 
        rest. 

        The domain is well suited for this. Something, like for example, the list of triggers and power-ups, 
        should be passable as an optional arg, or dodot will fetch the default ones. This has the benefit 
        of helping testability.

    3.2 API Sketch

        The api can be very functional: 

            local dodot = require("dodot.core")

            local potential_packs = dodot.get_pack_candidates(dotfiles_root)
            local packs = dodot.get_packs(potential_packs)
            local active_triggers = dodot.get_firing_triggers(packs) -- don't pass the second arg triggers
            local actions = dodot.get_action_list(active_triggers) -- don't pass actions
            local fs_operations = dodot.get_fs_ops(actions)
            fsynth.run(fs_operations)

        I'm being simplistic, but this is the sketch of the api / main handlers. For actions, power-ups and 
        triggers, the receiver gets the trigger definitions as second param:
            dodot.get_firing_triggers(packs, triggers) 
        Which if not provided will default to dodot.config.get_triggers()

    3.3 CLI Isolation

        The entire system is to be implemented as pure business logic, that is the dodot.deploy module 
        is only receiving full lua objects, not shell args. Likewise nothing prints to stdout.

        The dodot/cli.lua file is responsible for parsing args, validating and calling the appropriate 
        commands, but at that point, there is no cli.

    3.4 Data Types

        We need to both settle on the data type design as well as which ones we need for Triggers,
        Power-ups and Actions. (power-ups are defined and described in the concept problem)

        The core entities are:
        - Triggers: Pure matching logic 
        - Power-ups: Pure processing logic
        - Matchers: Configuration connecting the two
        - Actions: High-level operations to perform
        - Operations: fsynth filesystem operations

    3.5 Structure Error Handling

        See docs/errors.txxt.

4. Implementation Strategy

    4.1. Deploy Command First
        
        Since the core use is the deploy command (everything else will be its helper commands) that is 
        the one we want to do first. We'll implement it end-to-end including file system mutations and CLI.

    4.2. Reducing Scope
        
        a. Core Power-ups

            Instead of working on all power-ups at once, we'll work on a smaller subset that exercises 
            all the things that power-ups need to do:

            We'll do: 
                - symlink power-up (to user home)
                - profile power-up (add things to your shell)
                - bin power-up (add paths)

            These exercise most triggers needed and actions while not being extensive.

        b. No Customization Initially

            The use of melt allows us to normalize user customization in a black box way. Hence we will at 
            first work with no customization, but will keep the stubs for get_merged_config... 
            When the time comes, we should just change these to actually use melt.

        c. Registry System

            We want all matchers, triggers, actions and power-ups to be user extensible at some point, that is
            they are open systems, and hence they won't be hardcoded. All these will use a registry system, 
            lua/utils/registry.lua will handle this. 

            -- the registry
                local registry = require("dodot.utils.registry")

                triggers = registry.new()
                triggers.add("file_name", FileNameTrigger)
                triggers.get(key)
                triggers.remove.. triggers.list...

            the core dodot object will have
            
            dodot.libs.triggers, dodot.libs.actions, etc 
            
            The init for each category should be responsible for registering them (as in 
            dodot/actions/init.lua will register the actions and so forth)


    4.3. Project Layout

        Something like this:
        lua
        └── dodot
            ├── actions
            ├── cli.lua - does argument parsing and then calls business logic
            ├── libs.lua -> does the initial registry setup for each
            ├── core - sample one file per phase 
            │   ├── get_actions.lua
            │   ├── get_firing_triggers.lua
            │   ├── get_fs_ops.lua
            │   ├── get_packs.lua
            │   ├── list_packs.lua
            │   └── run_ops.lua
            ├── commands
            │   ├── list.lua
            │   └── deploy.lua
            ├── init.lua
            ├── matchers - dir for the matchers
            ├── powerups - dir for the power-ups
            ├── triggers - dir for the triggers
            └── utils
                └── registry.lua

5. Implementation Phases

    Phase 1: Infrastructure (Foundation)
        
        The goal is to have all the pieces in place, so that later we fine tune and work on each of the 
        specifics (triggers, power-ups, etc)
        
        - Implement the registry system
        - implement the error handling system (see docs/errors.txxt)
        - Implement code to validate packs
        - Implement the loops for run time stages (getting packs, validating, getting triggers, getting 
          actions, getting operations) one by one in a controlled and incremental manner
        - Set up proper lua module structure
        - Configure luarocks and dependencies  
        - Set up testing framework (busted)

        Deliverable: Can discover and validate packs, basic registry system works

    Phase 2: Core Concept Implementation
    
        We implement the first iterations of triggers, actions, etc, one by one as each power-up needs them.
        The goal here is to validate and hone the design, data types, etc.

        - Implement the Core Power-ups, one by one with the flow
        - FileNameTrigger implementation with globbing
        - DirectoryTrigger implementation
        - ExtensionTrigger implementation
        - Basic matcher system
        - symlink power-up (symlinking to home)
        - profile power-up (shell integration)
        - bin power-up (PATH management)

        Deliverable: Can scan packs and generate actions for core power-ups

    Phase 3: Operation Execution
        
        We implement and test the final operations run, that is, running the actual synthetic operations 
        into fs changes. The goal is to have confidence that core value of the program works.

        - Action-to-operation conversion
        - fsynth integration
        - Dry-run support
        - Error handling and rollback
        - Shell profile management
        - PATH manipulation

        Deliverable: Full working deploy command with file system mutations

    Phase 4: Deploy Command CLI
        
        With the business logic tested, we write the dodot.cli.lua that parses and validates arguments and calls
        dodot/commands/deploy.lua

        - Argument parsing for deploy command
        - Validation and error handling
        - CLI-to-business-logic bridge
        - Basic output formatting

        Deliverable: Working `dodot deploy` command

    Phase 5: Auxiliary Commands

        Now we implement the info, disable, etc, minor commands that support the deploy workflow.

        - info command (what would be deployed)
        - list command (show available packs)
        - disable command (pack management)
        - Verbose and debugging output

        Deliverable: Full command suite supporting deploy workflow

    Phase 6: Advanced Features

        Expand the system with more power-ups and triggers.

        - homebrew power-up (Brewfile support)
        - script_runner power-up (setup.sh execution)
        - ContentTrigger (file content matching)
        - CombinationTrigger (AND/OR logic)

        Deliverable: Full-featured power-up system

    Phase 7: Customization System
        
        One by one, implement customization layers:
        - User-wide customization (~/.dodot.toml)
        - Pack customization (toml file on pack)
        - Command line argument overrides
        - Environment variable support
        - Full melt integration

        Deliverable: Fully customizable system

    Phase 8: Testing and Polish
        
        Comprehensive testing and final polish.

        - Unit tests for all components
        - Integration tests
        - CLI tests
        - Documentation
        - Packaging and release preparation

        Deliverable: Production-ready dodot v1.0

6. Technical Implementation Notes

    6.1 File System Safety
        
        All file system operations go through fsynth for safety:
        - Validation before execution
        - Dry-run capability
        - Transactional rollback
        - Checksum verification

    6.2 Configuration Hierarchy (Later Phase)
        
        Configuration merging order (melt library):
        1. Built-in defaults
        2. Global ~/.dodot.toml  
        3. Pack-specific .dodot.toml
        4. Environment variables (DODOT_*)
        5. Command line arguments

    6.3 Error Handling Strategy
        
        Fail fast with clear messages:
        - Validate everything upfront
        - Provide actionable error messages
        - Support continuing on non-critical errors
        - Always allow dry-run for safety

    6.4 Testing Strategy
        
        Test each layer independently:
        - Pure functions for triggers and power-ups
        - Mock file system for integration tests
        - Actual file system for end-to-end tests
        - Property-based testing for edge cases

7. Success Criteria

    Phase 1: Can discover packs and basic registry works
    Phase 2: Can match files to power-ups and generate actions
    Phase 3: Can execute file system operations safely
    Phase 4: Can run `dodot deploy` from command line
    Phase 5: Can run `dodot info`, `dodot list`, etc.
    Phase 6: Can handle complex power-ups and triggers
    Phase 7: Can customize behavior through configuration
    Phase 8: Ready for public release

This implementation plan provides a clear roadmap focused on getting the deploy command working 
end-to-end first, with each phase building incrementally toward a complete solution.