dodot's execution
                

1. Overview 
    
    This is the implementation side of dodot, read the docs/concepts-and-design.txxt for the reasoning.

        1. Get configuration , resolve DOTFILES dir.
        2. Resolve pack name to paths, and validate (read access, no ignore, etc)  (validate packs)
        3. Through each pack:  (get firing triggers): -> array of triggers matches and their powerups.
            1. Resolve configuration including the pack's toml (if there is one)
            2. run triggers and accumulate which one fires  (get firing triggers)
        4.  Activate power up (gets a list of actions ) -> array of actions  per power-up
            1. iterate the active triggers running their power-ups for each pack and accumulating their actions (get power-ups actions)
        4. Plan Actions:  -> array of simple syntethic file systems operations to run 
            1. iterating their actions and transforming the into fsynth operations (get fs operations)
        4. Run: actually run these changes
            1. Execute all operations (the fsynth lib does the execution) (run operations)

    And the implementation for triggers, actions , power ups.

2. Libraries
    
    As we planned we either found or created lua libraries that handle an abstract lower level part of the 
    problem. These are: 

        - fysnth (https://luarocks.org/modules/arthur-debert/fsynth) 0.1.0 This is the we created for this 
        specific problem and hence it should serve us well. it has an api for creating file system operations
        and a runner to run it, as well as facilities for visualizing it.  /Users/adebert/h/lua/fsynth.lua/fsynth and 
        /Users/adebert/h/lua/fsynth.lua/docs

        - melt( https://luarocks.org/modules/arthur-debert/melt) 0.1.1 This rock allows you to declare a 
    chain of configuration (can be files, env vars, command line options) and get back a unified one , 
    merged in the right order. Locally source code and docs ~/h/lua/lua.melt/docs ~/h/lua/lua.melt/lua
/Users/adebert/h/lua/lua.melt/docs:


3. Design

    3.1. Functional Programming
        
        We favor a functional programming style for the various benefits that it allows. Given that the most 
        difficult part to make functional are all file system operations, we should have no difficulty with the 
        rest. 

        The domain is well suited for this. Somethings, like for example, the list of triggers and powerups, 
        should  be passable as on optional arg, or dodot will fetch the default ones. This has the benefit 
        of helping testability

    3.2 API Sketch

        

            -- The api can be very functional: 

                local dotot =  require("dodot.core")

                local potential_packs = dodot.get_pack_candidates(dotfiles_root)
                local packs = dodot.get_packs(potential_packs)
                local active_triggers= dodot.get_firing_triggers(packs) -- don't pass the second arg triggers
                local actions =- dodot.get_action_list(active_triggers) -- don't pass actions
                local fs_operations = get_fs_ops(actions)
                fsynth.run(fs_operations)

            -- lua

        I'm being simplistic, but this is the sketch of the api / main handlers. For actions, power-ups and 
        trigers,  the receives the trigger definitions as second param
                dodot.get_firing_triggers(packs, triggers) 
        Which if not provided with default to dodot.config.get_triggers()

    3.3 DataTypes

        We need to both settle on the data type design as well as the which ones do we nee for Triggers,
         Power-ups and Actions .  (power-ups are defined and described in the concept problem)

4. Execution Plan

    We'll do the implementation in phases, selecting both features and functionalities to focus incrementally.
    
    1. Reducing scope
        
        Since the core use is the deploy command (everything else will be it's helper commands) that is 
        the one we want to do first. 

        a. Core PowerUps

            Instead of working on all powerups at once, we'll work on a smaller subset that is quite of all 
            things that powerups needs to do, as well as good triggers tests beds and so forth.

            We'll do: 

                - symlink power up (to user home)
                - profile powerup (add things to your shell)
                - bin powerup (add paths)

            These exercise most triggers needed and actions while not being extensive.

        b. No Customization

            The use of melt allowes us to normalize user customization in a black box way. Hence we will at 
            first work with the non customization ideas, but, will keep the stubs for get_merged_config... 
            When the time comes, we should just change these to actually use melt.

        c. No file operations. 

            We rely and trust on fsynth do execute a batch of synthetic ops into real fs changes, hence, 
            while in the  very end we should have a couple of full integration tests to verify, we can mostly
            presuppose that can stop at the final operations list.

    2. Registries

        We want all matchers, triggers, actions and powerups to be user extensible at some point, that is
        they are open systems, and hence they won't be hardcoded. All these will use a registry sytem, 
        lua/utils/registry.lua will handle. 

         -- the registry
            local registry = require("dodot.utils.registry")

            triggers = registry.new()
            triggers.add("file_name", FileNameTrigger)
            triggers.get( key)
            triggers.remove.. triggers list...

        the core dodot object will have
        
        dodot.libs.triggers , dodot.libs.actions, etc 
        
        The init for each category should be responsible for registring them (as in 
        dodot/actions/init.lua will register the actions and so forth)

        Because all of these are simple tables with names objects, they are easy to mock during testing


    d. Layout: 

        Something like this
        lua
        └── dodot
            ├── actions
            ├── cli.lua - does argument parsing and then calls business logic
            ├── libs.lua -> does the inital registry setup for each
            ├── core - sample one file per phase 
            │   ├── get_actions.lua
            │   ├── get_firing_triggers
            │   ├── get_fs_ops.lua
            │   ├── get_packs.lua
            │   ├── list_packs.lua
            │   └── run_ops.lua
            ├── commands
            │   ├── list.lua
                └── deploy.lua
            ├── init.lua
            ├── matchers - dir for the matchers
            ├── powerups - dir for the powerups
            ├── triggers - dir for the triggers
            └── utils
                └── registry.lua

    e. CLI Isolation

        The entire system is to be implemented as pure business logic, that is the dodot.deploy module 
        is only receiving full lua objects, not shell sargs. Likewise nothing prints to stdout.

        the dodot/cli.lua file is responsible for parsing args, validating and calling the appropriate 
        commands, but at that point, there is no cli.

5. Phases: 

    5.1 Infrasturcture

    The goal is to have all the pieces in places, so that later we fine tune this and work on each of the 
    specifics (triggers, powerups, etc)
    
        - Implement the registry
        - Implent code to validate packs
        - implement the loops for run time stages (getting packs, validating, getting triggers, getting 
        actions, getting operations) one by one in a controled and incremental manner
        
    5.2 Concept 
    
    We implement the first iterations of triggers , actions, etc, one by one as each power up needs them.
    The goal here is to validate and hone the design, data types, etc.

    - Implement the Core Powerups, one by one with the flow


    5.3 Expansion

    We finish all power-us and associated libs.

    5.4 Real World

    We implement and test the final operations run, that is , running the actual synthetic operations 
    into  fs changes.

    The goal is to have confidence  that core value of the program works, the deploy command.

    5.5 Auxiliary commands

    Now we do the info, disable, etc, minor commands


    5.6 The Acutal CLI

    With everything tested, we write the the dotot.cli.lua that parses and validates arguments and calls
    dodot/commands/<command>.lua

    5.7 customizations
        One by one, inner releases for
        - user wide customiztion
        -  pack customiztion (toml file on pack)
        -  command line args