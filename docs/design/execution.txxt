dodot Implementation and Execution
                

1. Overview 
    
    This is the implementation side of dodot, read the docs/concepts-and-design.txxt for the reasoning.

    The execution pipeline follows these steps:
        1. Get configuration, resolve DOTFILES dir.
        2. Resolve pack names to paths, and validate (read access, no ignore, etc)  
        3. Through each pack: 
            a. Resolve configuration including the pack's toml (if there is one)
            b. Run matchers and accumulate which ones fire  (get firing matchers)
            c. Iterate the active matchers running their power-ups for each pack and accumulating their actions (get power-ups actions)
        4. Plan Actions: Transform actions into fsynth operations (get fs operations)
        5. Run: actually execute these changes via fsynth (run operations)

    And the implementation for matchers, triggers, actions, and power-ups.

2. Libraries
    
    As we planned we either found or created lua libraries that handle an abstract lower level part of the 
    problem. These are: 

        - fsynth (https://luarocks.org/modules/arthur-debert/fsynth) 0.1.0 This is the one we created for this 
        specific problem and hence it should serve us well. It has an api for creating file system operations
        and a runner to run it, as well as facilities for visualizing it.  /Users/adebert/h/lua/fsynth.lua/fsynth and 
        /Users/adebert/h/lua/fsynth.lua/docs

        - melt (https://luarocks.org/modules/arthur-debert/melt) 0.1.1 This rock allows you to declare a 
        chain of configuration (can be files, env vars, command line options) and get back a unified one, 
        merged in the right order. Locally source code and docs ~/h/lua/lua.melt/docs ~/h/lua/lua.melt/lua

3. Design Principles

    3.1. Functional Programming
        
        We favor a functional programming style for the various benefits that it allows. Given that the most 
        difficult part to make functional are all file system operations, we should have no difficulty with the 
        rest. 

        The domain is well suited for this. Something, like for example, the list of matchers and power-ups, 
        should be passable as an optional arg, or dodot will fetch the default ones. This has the benefit 
        of helping testability.

    3.2 API Sketch

        The api can be very functional: 

            local dodot = require("dodot.core")

            local potential_packs = dodot.get_pack_candidates(dotfiles_root)
            local packs = dodot.get_packs(potential_packs)
            local matchers = dodot.get_matchers(config) 
            local matches = dodot.get_matches(packs, matchers) 
            local actions = dodot.get_actions(matches)
            local fs_operations = dodot.get_operations(actions)
            fsynth.execute(fs_operations)

        I'm being simplistic, but this is the sketch of the api / main handlers. For actions, power-ups and 
        matchers, the receivers get the configuration definitions as second param:
            dodot.get_matches(packs, matchers) 
        Which if not provided will default to dodot.config.get_default_matchers()

    3.3 Data Types

        We need to both settle on the data type design as well as which ones we need for Triggers,
        Power-ups and Actions. (power-ups are defined and described in the concept problem)

        The core entities are:
        - Triggers: Pure matching logic 
        - Power-ups: Pure processing logic
        - Matchers: Configuration connecting the two
        - Actions: High-level operations to perform
        - Operations: fsynth filesystem operations

4. Implementation Roadmap

    Phase 1: Foundation (Milestone M1)
        
        Core infrastructure and basic functionality.

        M1.1 Project Structure
            - Set up proper lua module structure
            - Configure luarocks and dependencies  
            - Set up testing framework (busted)
            - Basic CLI structure with subcommands

        M1.2 Configuration System
            - Implement config loading with melt
            - DOTFILES_ROOT resolution
            - Basic .dodot.toml support
            - Environment and CLI option handling

        M1.3 Pack Discovery
            - Pack scanning and validation
            - Basic pack metadata extraction
            - Pack ignore logic (.dodot.toml ignore=true)

        Deliverable: Can discover and validate packs, load configuration

    Phase 2: Core Matching Engine (Milestone M2)
        
        Implement the trigger and matcher system.

        M2.1 Trigger Framework
            - Base trigger interface and validation
            - FileNameTrigger implementation with globbing
            - DirectoryTrigger implementation
            - ExtensionTrigger implementation

        M2.2 Matcher System  
            - Matcher configuration loading
            - Priority-based conflict resolution
            - Default matcher definitions
            - User override system

        M2.3 Match Resolution
            - File scanning within packs
            - Match execution and metadata collection
            - Conflict resolution by priority
            - Match grouping by power-up

        Deliverable: Can scan packs and identify which files match which power-ups

    Phase 3: Power-ups and Actions (Milestone M3)
        
        Implement power-ups and action generation.

        M3.1 Power-up Framework
            - Base power-up interface
            - Power-up registry and loading
            - Validation and error handling

        M3.2 Core Power-ups
            - link_home power-up (symlink to ~/)
            - link_xdg power-up (symlink to ~/.config)
            - shell_profile power-up (shell integration)
            - path_add power-up (PATH management)

        M3.3 Action System
            - Action data structures
            - Action validation and prioritization
            - Action to operation mapping

        Deliverable: Can generate actions from matched files

    Phase 4: Operation Execution (Milestone M4)
        
        Convert actions to fsynth operations and execute.

        M4.1 Operation Builders
            - Action-to-operation conversion
            - fsynth operation construction
            - Operation queue management

        M4.2 Execution Engine
            - fsynth integration
            - Dry-run support
            - Transactional execution
            - Error handling and rollback

        M4.3 Shell Integration
            - Shell profile management
            - Ordered script sourcing
            - PATH manipulation
            - Alias management

        Deliverable: Full working deployment pipeline

    Phase 5: Advanced Features (Milestone M5)
        
        Polish and advanced functionality.

        M5.1 Advanced Power-ups
            - homebrew power-up (Brewfile support)
            - script_runner power-up (setup.sh execution)
            - Custom power-up system

        M5.2 Advanced Triggers
            - ContentTrigger (file content matching)
            - CombinationTrigger (AND/OR logic)
            - Custom trigger system

        M5.3 CLI Enhancement
            - info command (what would be deployed)
            - disable command (pack management)
            - Verbose and debugging output
            - Better error messages

        Deliverable: Full-featured dodot v1.0

    Phase 6: Testing and Documentation (Milestone M6)
        
        Comprehensive testing and documentation.

        M6.1 Test Suite
            - Unit tests for all components
            - Integration tests
            - CLI tests
            - Regression tests

        M6.2 Documentation
            - User guide and examples
            - API documentation  
            - Troubleshooting guide
            - Migration guide from other tools

        M6.3 Packaging
            - Luarocks packaging
            - Installation scripts
            - Release automation

        Deliverable: Production-ready dodot with full documentation

5. Technical Implementation Notes

    5.1 File System Safety
        
        All file system operations go through fsynth for safety:
        - Validation before execution
        - Dry-run capability
        - Transactional rollback
        - Checksum verification

    5.2 Configuration Hierarchy
        
        Configuration merging order (melt library):
        1. Built-in defaults
        2. Global ~/.dodot.toml  
        3. Pack-specific .dodot.toml
        4. Environment variables (DODOT_*)
        5. Command line arguments

    5.3 Error Handling Strategy
        
        Fail fast with clear messages:
        - Validate everything upfront
        - Provide actionable error messages
        - Support continuing on non-critical errors
        - Always allow dry-run for safety

    5.4 Testing Strategy
        
        Test each layer independently:
        - Pure functions for triggers and power-ups
        - Mock file system for integration tests
        - Actual file system for end-to-end tests
        - Property-based testing for edge cases

6. Development Milestones Schedule

    Estimated timeline (assuming part-time development):

    M1 (Foundation): 2-3 weeks
        Critical path: Configuration system and pack discovery

    M2 (Matching): 3-4 weeks  
        Critical path: Matcher priority resolution

    M3 (Power-ups): 2-3 weeks
        Critical path: Shell integration complexity

    M4 (Execution): 2-3 weeks
        Critical path: fsynth integration and error handling

    M5 (Advanced): 3-4 weeks
        Critical path: Homebrew integration and complex triggers

    M6 (Polish): 2-3 weeks
        Critical path: Documentation and packaging

    Total: 14-20 weeks (3-5 months)

    Each milestone should be fully functional and tested before proceeding to the next.

7. Success Criteria

    M1: Can run `dodot info` and see discovered packs
    M2: Can run `dodot info <pack>` and see what would match
    M3: Can run `dodot deploy --dry-run` and see generated actions  
    M4: Can run `dodot deploy` and successfully deploy basic packs
    M5: Can handle complex packs with multiple power-ups
    M6: Ready for public release

This implementation plan provides a clear roadmap from concept to working tool, with each 
milestone building on the previous one while maintaining functionality.