-- lua/dodot/core/get_fs_ops.lua
local types = require("dodot.types")
local errors = require("dodot.errors")
local pl_path = require("pl.path")

local M = {}

-- Constants for shell source paths
local DODOT_SHELL_BASE_DIR_NAME = "dodot/shell"
local ALIASES_SUBDIR_NAME = "aliases"
local PROFILE_SUBDIR_NAME = "profile_scripts"
local INIT_SCRIPT_NAME = "init.sh"

-- Helper to get home directory, trying multiple environment variables
local function get_home_directory()
    return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function build_shell_source_ops(action)
    local ops = {}

    if not action.data or not action.data.source_file then
        return nil, errors.create("INVALID_ACTION_DATA", { "shell_source", "Missing source_file in data" })
    end

    local home_dir = get_home_directory()
    if not home_dir then
        -- This error should now be defined in errors/codes.lua
        return nil, errors.create("MISSING_HOME_DIR", { "shell_source", "User home directory not found" })
    end

    local config_dir = os.getenv("XDG_CONFIG_HOME") or pl_path.join(home_dir, ".config")
    local full_base_path = pl_path.join(config_dir, DODOT_SHELL_BASE_DIR_NAME)

    local sub_dir_name = PROFILE_SUBDIR_NAME
    if action.data.source_file:match("alias") then
        sub_dir_name = ALIASES_SUBDIR_NAME
    end
    local target_subdir = pl_path.join(full_base_path, sub_dir_name)

    table.insert(ops, {
        type = "fsynth.op.ensure_dir",
        description = "Ensure dodot shell base directory exists: " .. full_base_path,
        args = { path = full_base_path, mode = "0755" }
    })
    table.insert(ops, {
        type = "fsynth.op.ensure_dir",
        description = "Ensure dodot shell target subdirectory exists: " .. target_subdir,
        args = { path = target_subdir, mode = "0755" }
    })

    local source_basename = pl_path.basename(action.data.source_file)
    local order_prefix = string.format("%02d", action.data.order or 50)
    local symlink_name = order_prefix .. "-" .. source_basename
    local symlink_path = pl_path.join(target_subdir, symlink_name)

    local absolute_source_file = action.data.source_file
    if action.pack_path and not pl_path.isabs(absolute_source_file) then
        absolute_source_file = pl_path.abspath(pl_path.join(action.pack_path, absolute_source_file))
    elseif not pl_path.isabs(absolute_source_file) then
        print("Warning: shell_source source_file is not absolute and no pack_path provided: " .. absolute_source_file)
    end

    table.insert(ops, {
        type = "fsynth.op.symlink",
        description = "Symlink shell script " .. absolute_source_file .. " to " .. symlink_path,
        args = { src = absolute_source_file, dest = symlink_path, force = true }
    })

    local init_script_path = pl_path.join(full_base_path, INIT_SCRIPT_NAME)
    local xdg_config_home_var = "${XDG_CONFIG_HOME:-$HOME/.config}"
    local script_base_dir_in_shell = xdg_config_home_var .. "/" .. DODOT_SHELL_BASE_DIR_NAME

    local init_content_parts = {
        "#!/bin/sh",
        "# Sources all scripts managed by dodot.",
        "# This script is auto-generated by dodot. Do not edit manually.",
        "",
        "__dodot_source_files_from_dir() {",
        "  local dir=\"$1\"",
        "  if [ -d \"$dir\" ]; then",
        "    for f in \"$dir\"/*; do", -- No quotes around * to allow globbing
        "      if [ -f \"$f\" ]; then",
        "        . \"$f\"",
        "      fi",
        "    done",
        "  fi",
        "}",
        "",
        "# Source aliases",
        "__dodot_source_files_from_dir \"" .. script_base_dir_in_shell .. "/" .. ALIASES_SUBDIR_NAME .. "\"",
        "",
        "# Source profile scripts",
        "__dodot_source_files_from_dir \"" .. script_base_dir_in_shell .. "/" .. PROFILE_SUBDIR_NAME .. "\"",
        "",
        "unset __dodot_source_files_from_dir" -- Clean up helper function
    }
    local init_content = table.concat(init_content_parts, "\n") .. "\n"

    table.insert(ops, {
        type = "fsynth.op.create_file",
        description = "Create/Update dodot init script: " .. init_script_path,
        args = { path = init_script_path, content = init_content, mode = "0755", overwrite = true }
    })
    return ops, nil
end

-- This dispatch table maps action types to functions that build fs operations.
local action_to_op_builder = {
    link_stub = function(action)
        -- Validate action.data structure for link_stub if needed
        if not action.data or not action.data.src or not action.data.dest then
            return nil, errors.create("INVALID_ACTION_DATA", { "link_stub", "Missing src or dest in data" })
        end
        return {
            {
                type = "fsynth.op.symlink_stub",
                description = action.description or "Stub symlink operation from link_stub action",
                args = action.data
            }
        }, nil -- No error
    end,
    shell_source = build_shell_source_ops, -- Added shell_source builder
    -- In the future, other action types like "copy_file", "ensure_dir" would have entries here.
    -- e.g.,
    -- copy_file = function(action)
    --     return {{ type = "fsynth.op.copy_file", args = action.data }}, nil
    -- end,
}

function M.get_fs_ops(actions_list)
    local operations = {}
    if not actions_list then return operations, nil end

    for _, action in ipairs(actions_list) do
        if not action or not action.type then
            print("Warning: Skipping malformed action (missing type or action itself is nil).")
        else
            local builder = action_to_op_builder[action.type]
            if builder then
                local success, result = pcall(builder, action)
                if success then
                    if type(result) == "table" and result.message and result.code then
                        print("Error building ops for action type " .. action.type .. ": " .. result.message)
                    elseif type(result) == "table" then
                        for _, op in ipairs(result) do
                            table.insert(operations, op)
                        end
                        -- else: builder might validly return nil or non-table if no ops for valid action data
                    end
                else
                    print("Critical error in builder for action type " .. action.type .. ": " .. tostring(result))
                end
            else
                print("Warning: No operation builder found for action type: " .. action.type)
            end
        end
    end
    return operations, nil
end

return M
